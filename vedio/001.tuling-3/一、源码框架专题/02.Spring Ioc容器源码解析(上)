视频讲师：司马
视频日期：2019-06-12 20:13

* * *

[TOC]

* * *

BeanFactoryPostProcessor和BeanDefinitionPostProcessor和ApplicationListener

* * *

# 01.Spring是如何发布事件的? ApplicationListener

1) 自己写一个TulingApplicationListener 实现ApplicationListener​接口,并且把该组件加入到容器中.

创建CustomApplicationListener类：

```java
package luckyyyyyyluke.tuling.course002.custom;

import org.springframework.context.ApplicationEvent;
import org.springframework.context.ApplicationListener;
import org.springframework.stereotype.Component;

@Component
public class CustomApplicationListener implements ApplicationListener {
    @Override
    public void onApplicationEvent(ApplicationEvent event) {

        System.out.println("CustomApplicationListener接收到事件：" + event);
    }
}
```

创建ComponentScanConfig类：

```java
package luckyyyyyyluke.tuling.course002.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan(basePackages = "luckyyyyyyluke.tuling.course002.custom")
public class ComponentScanConfig {
}
```

创建MainClass类：

```java
package luckyyyyyyluke.tuling.course002;

import luckyyyyyyluke.tuling.course002.config.ComponentScanConfig;
import org.springframework.context.ApplicationEvent;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class MainClass {

    public static void main(String[] args) {
        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(ComponentScanConfig.class);

        applicationContext.publishEvent(new ApplicationEvent("MainClass发布事件") {
            @Override
            public Object getSource() {
                return super.getSource();
            }
        });

        applicationContext.close();
    }
}
```

运行MainClass类：

```
CustomApplicationListener接收到事件：org.springframework.context.event.ContextRefreshedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@10bdf5e5: startup date [Sun Jul 18 11:16:45 CST 2021]; root of context hierarchy]
CustomApplicationListener接收到事件：luckyyyyyyluke.tuling.course002.MainClass$1[source=MainClass发布事件]
CustomApplicationListener接收到事件：org.springframework.context.event.ContextClosedEvent[source=org.springframework.context.annotation.AnnotationConfigApplicationContext@10bdf5e5: startup date [Sun Jul 18 11:16:45 CST 2021]; root of context hierarchy]
```

源码解析：

```
org.springframework.context.support.AbstractApplicationContext#refresh
|-- ①initApplicationEventMulticaster()
|-- ②registerListeners()
    |-- getApplicationEventMulticaster().multicastEvent(earlyEvent)
        |-- ③multicastEvent(event, resolveDefaultEventType(event))
            |-- invokeListener(listener, event)
                |-- ④doInvokeListener(listener, event)
```

①initApplicationEventMulticaster：
初始化事件多播器源码解析

```java
/**
 * Initialize the ApplicationEventMulticaster.
 * Uses SimpleApplicationEventMulticaster if none defined in the context.
 * @see org.springframework.context.event.SimpleApplicationEventMulticaster
 */
protected void initApplicationEventMulticaster() {
    ConfigurableListableBeanFactory beanFactory = getBeanFactory();
    // 判断IOC容器中包含applicationEventMulticaster 事件多播器的Bean的name
    if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) {
        // 创建一个applicationEventMulticaster的bean放在IOC 容器中,bean的name 为applicationEventMulticaster
        this.applicationEventMulticaster =
                beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);
        if (logger.isDebugEnabled()) {
            logger.debug("Using ApplicationEventMulticaster [" + this.applicationEventMulticaster + "]");
        }
    }
    else {
        // 容器中不包含一个beanName 为applicationEventMulticaster的多播器组件
        // 创建一个SimpleApplicationEventMulticaster 多播器
        this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);
        // 注册到容器中
        beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster);
        if (logger.isDebugEnabled()) {
            logger.debug("Unable to locate ApplicationEventMulticaster with name '" +
                    APPLICATION_EVENT_MULTICASTER_BEAN_NAME +
                    "': using default [" + this.applicationEventMulticaster + "]");
        }
    }
}
```

②registerListeners：
把容器中的监听器注册到多播器上去 源码解析

```java
/**
  * Add beans that implement ApplicationListener as listeners.
  * Doesn't affect other listeners, which can be added without being beans.
  */
protected void registerListeners() {
    // Register statically specified listeners first.
    // 去容器中把applicationListener 捞取出来注册到多播器上去（系统的）
    for (ApplicationListener<?> listener : getApplicationListeners()) {
        getApplicationEventMulticaster().addApplicationListener(listener);
    }

    // Do not initialize FactoryBeans here: We need to leave all regular beans
    // uninitialized to let post-processors apply to them!
    // 我们自己实现了ApplicationListener 的组件
    String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);
    for (String listenerBeanName : listenerBeanNames) {
        getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);
    }

    // Publish early application events now that we finally have a multicaster...
    // 在这里之前，我们早期想发布的事件 由于没有多播器没有发布，在这里我们总算有了自己的多播器，可以在这里发布早期堆积的事件了
    Set<ApplicationEvent> earlyEventsToProcess = this.earlyApplicationEvents;
    this.earlyApplicationEvents = null;
    if (earlyEventsToProcess != null) {
        for (ApplicationEvent earlyEvent : earlyEventsToProcess) {
            getApplicationEventMulticaster().multicastEvent(earlyEvent);
        }
    }
}
```

③multicastEvent(event, resolveDefaultEventType(event))：
如何发布事件 源码解析

```java
@Override
public void multicastEvent(final ApplicationEvent event, ResolvableType eventType) {
    ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));
    // 获取到所有的监听器
    for (final ApplicationListener<?> listener : getApplicationListeners(event, type)) {
        // 看spring 容器中是否支持线程池 异步发送事件
        Executor executor = getTaskExecutor();
        if (executor != null) {
            executor.execute(new Runnable() {
                @Override
                public void run() {
                    invokeListener(listener, event);
                }
            });
        }
        else {
            // 同步发送事件
            invokeListener(listener, event);
        }
    }
}
```

④doInvokeListener(listener, event)：

```java
/**
  * Invoke the given listener with the given event.
  * @param listener the ApplicationListener to invoke
  * @param event the current event to propagate
  * @since 4.1
  */
protected void invokeListener(ApplicationListener<?> listener, ApplicationEvent event) {
    ErrorHandler errorHandler = getErrorHandler();
    if (errorHandler != null) {
        try {
            // 调用对于listener的onApplicationEvent事件
            doInvokeListener(listener, event);
        }
        catch (Throwable err) {
            errorHandler.handleError(err);
        }
    }
    else {
        doInvokeListener(listener, event);
    }
}
```

* * *

# 02.BeanDefinitionRegistryPostProcessor的处理源码流程

执行时机:所有的bean定义信息将要被加载到容器中，Bean实例还没有被初始化。

创建CustomBeanDefinationRegisterPostProcessor类：

```java
package luckyyyyyyluke.tuling.course002.custom;

import luckyyyyyyluke.tuling.course002.component.C1_Component;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
import org.springframework.beans.factory.support.BeanDefinitionRegistry;
import org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor;
import org.springframework.beans.factory.support.RootBeanDefinition;
import org.springframework.stereotype.Component;

@Component
public class CustomBeanDefinationRegisterPostProcessor implements BeanDefinitionRegistryPostProcessor {
    @Override
    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {
        System.out.println("CustomBeanDefinationRegisterPostProcessor的postProcessBeanDefinitionRegistry方法");
        System.out.println("bean定义的数据量:"+registry.getBeanDefinitionCount());
        RootBeanDefinition rootBeanDefinition = new RootBeanDefinition(C1_Component.class);
        registry.registerBeanDefinition("c1_Component",rootBeanDefinition);
    }

    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
        System.out.println("CustomBeanDefinationRegisterPostProcessor的postProcessBeanFactory方法");
        System.out.println(beanFactory.getBeanDefinitionCount());
    }
}
```

* * *

# 03.BeanFactoryPostProcessor 处理流程

执行时间:所有的Bean定义信息已经加载到容器中，但是Bean实例还没有被初始化.

```java
package luckyyyyyyluke.tuling.course002.custom;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.config.BeanFactoryPostProcessor;
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
import org.springframework.stereotype.Component;

@Component
public class CustomBeanFactoryPostProcessor implements BeanFactoryPostProcessor {
    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
        System.out.println("IOC 容器调用了CustomBeanFactoryPostProcessor的postProcessBeanFactory方法");
        for(String name:beanFactory.getBeanDefinitionNames()) {
            if("c1_Component".equals(name)) {
                BeanDefinition beanDefinition = beanFactory.getBeanDefinition(name);
                beanDefinition.setLazyInit(true);
            }
        }
    }
}
```

调用链:

```
org.springframework.context.support.AbstractApplicationContext#refresh
|-- invokeBeanFactoryPostProcessors(beanFactory)
    |-- PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors())
        |-- ①invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry)
            |-- postProcessor.postProcessBeanDefinitionRegistry(registry)
                |-- ②processConfigBeanDefinitions(registry)
                    |-- ③parser.parse(candidates)
                        |-- parse(bd.getBeanClassName(), holder.getBeanName())
                            |-- ④processConfigurationClass(new ConfigurationClass(reader, beanName))
                                |-- ⑤sourceClass = doProcessConfigurationClass(configClass, sourceClass);
                                    |-- ⑥this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())
                                        |-- ⑦ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(this.registry,componentScan.getBoolean("useDefaultFilters"), this.environment, this.resourceLoader);
                                        |	|-- ⑧registerDefaultFilters()
                                        |
                                        |-- ⑨scanner.doScan(StringUtils.toStringArray(basePackages))
                                        	|-- ⑩Set<BeanDefinition> candidates = findCandidateComponents(basePackage)
                                        		|-- ⑪if (isCandidateComponent(metadataReader))
                                        			|-- ⑫return isConditionMatch(metadataReader)
```

①invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry)

标记处源码解析

```java
// 在上下文中调用注册为bean的工厂处理器
public static void invokeBeanFactoryPostProcessors(
        ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {

    // Invoke BeanDefinitionRegistryPostProcessors first, if any.
    Set<String> processedBeans = new HashSet<String>();

    if (beanFactory instanceof BeanDefinitionRegistry) {
        // 把IOC容器 强制转为BeanDefinitionRegistry类型的
        BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
        // 创建一个普通的PostProcessors的list的组件
        List<BeanFactoryPostProcessor> regularPostProcessors = new LinkedList<BeanFactoryPostProcessor>();
        // 创建一个BeanDefinitionRegistryPostProcessor类型的list
        List<BeanDefinitionRegistryPostProcessor> registryProcessors = new LinkedList<BeanDefinitionRegistryPostProcessor>();

        // 处理容器硬编码(new 出来的)带入的beanFacotryPostProcessors
        for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
            // 判断是不是BeanDefinitionRegistryPostProcessor
            if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
                BeanDefinitionRegistryPostProcessor registryProcessor =
                        (BeanDefinitionRegistryPostProcessor) postProcessor;
                // 调用BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry
                registryProcessor.postProcessBeanDefinitionRegistry(registry);
                // 加入到list集合中
                registryProcessors.add(registryProcessor);
            }
            else {
                // 加入到集合中
                regularPostProcessors.add(postProcessor);
            }
        }

        // Do not initialize FactoryBeans here: We need to leave all regular beans
        // uninitialized to let the bean factory post-processors apply to them!
        // Separate between BeanDefinitionRegistryPostProcessors that implement
        // PriorityOrdered, Ordered, and the rest.
        // 创建一个当前注册的RegistryProcessors的集合
        List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList<BeanDefinitionRegistryPostProcessor>();

        // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
        // 第一步:去容器中查询是否有BeanDefinitionRegistryPostProcessor类型的
        String[] postProcessorNames =
                beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
        for (String ppName : postProcessorNames) {
            // 判断是不是实现了PriorityOrdered接口的
            if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
                // 添加到currentRegistryProcessors的集合中
                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                // 添加到processedBeans的集合中
                processedBeans.add(ppName);
            }
        }metadata
        // 进行排序
        sortPostProcessors(currentRegistryProcessors, beanFactory);
        registryProcessors.addAll(currentRegistryProcessors);
        // 调用BeanDefinitionRegistryPostProcessors的postProcessBeanDefinitionRegistry方法
        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
        currentRegistryProcessors.clear();

        // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
        // 第二步:去容器中查询是否有BeanDefinitionRegistryPostProcessor类型的
        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
        for (String ppName : postProcessorNames) {
            if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {
                // 排除被处理过的，并且实现了Ordered接口的
                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                // 加到以处理的list中
                processedBeans.add(ppName);
            }
        }
        sortPostProcessors(currentRegistryProcessors, beanFactory);
        registryProcessors.addAll(currentRegistryProcessors);
        // 调用BeanDefinitionRegistryPostProcessors的postProcessBeanDefinitionRegistry方法
        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
        currentRegistryProcessors.clear();

        // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
        // 调用普通的BeanDefinitionRegistryPostProcessors没用实现 PriorithOrdered和Ordered接口
        boolean reiterate = true;
        while (reiterate) {
            reiterate = false;
            postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
            for (String ppName : postProcessorNames) {
                if (!processedBeans.contains(ppName)) {
                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                    processedBeans.add(ppName);
                    reiterate = true;
                }
            }
            sortPostProcessors(currentRegistryProcessors, beanFactory);
            registryProcessors.addAll(currentRegistryProcessors);
            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
            currentRegistryProcessors.clear();
        }

        // Now, invoke the postProcessBeanFactory callback of all processors handled so far.
        // 调用上诉实现了也实现了BeanFactoryPostProcessors的接口
        invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
        invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
    }

    else {
        // Invoke factory processors registered with the context instance.
        invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);
    }

    // Do not initialize FactoryBeans here: We need to leave all regular beans
    // uninitialized to let the bean factory post-processors apply to them!
    // 去IOC 容器中获取BeanFactoryPostProcessor 类型的
    String[] postProcessorNames =
            beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);

    // Separate between BeanFactoryPostProcessors that implement PriorityOrdered,
    // Ordered, and the rest.
    // 分离实现了PriorityOrdered接口的 Ordered 接口的 普通的
    List<BeanFactoryPostProcessor> priorityOrderedPostProcessors = new ArrayList<BeanFactoryPostProcessor>();
    List<String> orderedPostProcessorNames = new ArrayList<String>();
    List<String> nonOrderedPostProcessorNames = new ArrayList<String>();
    for (String ppName : postProcessorNames) {
        if (processedBeans.contains(ppName)) {
            // skip - already processed in first phase above
        }
        else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
            priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));
        }
        else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
            orderedPostProcessorNames.add(ppName);
        }
        else {
            nonOrderedPostProcessorNames.add(ppName);
        }
    }

    // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.
    // 调用 PriorityOrdered
    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
    invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);

    // Next, invoke the BeanFactoryPostProcessors that implement Ordered.
    // 调用 Ordered
    List<BeanFactoryPostProcessor> orderedPostProcessors = new ArrayList<BeanFactoryPostProcessor>();
    for (String postProcessorName : orderedPostProcessorNames) {
        orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
    }
    sortPostProcessors(orderedPostProcessors, beanFactory);
    invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);

    // Finally, invoke all other BeanFactoryPostProcessors.
    // 调用普通的
    List<BeanFactoryPostProcessor> nonOrderedPostProcessors = new ArrayList<BeanFactoryPostProcessor>();
    for (String postProcessorName : nonOrderedPostProcessorNames) {
        nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
    }
    invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);

    // Clear cached merged bean definitions since the post-processors might have
    // modified the original metadata, e.g. replacing placeholders in values...
    beanFactory.clearMetadataCache();
}
```

②processConfigBeanDefinitions(registry)
源码解析

```java
/**
  * Build and validate a configuration model based on the registry of
  * {@link Configuration} classes.
  */
public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
    List<BeanDefinitionHolder> configCandidates = new ArrayList<BeanDefinitionHolder>();
    
    // 去IOC容器中的获取Bean定义的名称
    // private volatile List<String> beanDefinitionNames = new ArrayList<String>(256);
    
    // 没有解析之前，系统候选的bean定义配置(有自己的 有系统自带的)
    String[] candidateNames = registry.getBeanDefinitionNames();

    // 循环Bean定义的名称 找出自己的传入的主配置类的bean定义信息  configCandidates
    for (String beanName : candidateNames) {
        // 去bean定义的map中获取对应的Bean定义对象
		// private final Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<String, BeanDefinition>(256);
        BeanDefinition beanDef = registry.getBeanDefinition(beanName);
        // 检查该bean定义对象是不是用来描述配置类
        if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||
                ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {
            if (logger.isDebugEnabled()) {
                logger.debug("Bean definition has already been processed as a configuration class: " + beanDef);
            }
        }
        else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
        }
    }

    // Return immediately if no @Configuration classes were found
    if (configCandidates.isEmpty()) {
        return;
    }

    // Sort by previously determined @Order value, if applicable
    // 检查配置类排序
    Collections.sort(configCandidates, new Comparator<BeanDefinitionHolder>() {
        @Override
        public int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) {
            int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());
            int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());
            return (i1 < i2) ? -1 : (i1 > i2) ? 1 : 0;
        }
    });

    // Detect any custom bean name generation strategy supplied through the enclosing application context
    // bean的名称生成策略
    SingletonBeanRegistry sbr = null;
    if (registry instanceof SingletonBeanRegistry) {
        sbr = (SingletonBeanRegistry) registry;
        if (!this.localBeanNameGeneratorSet && sbr.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {
            BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);
            this.componentScanBeanNameGenerator = generator;
            this.importBeanNameGenerator = generator;
        }
    }

    // Parse each @Configuration class
    // ***创建一个配置类解析器
	//	1)元数据读取器工厂
	//	this.metadataReaderFactory = metadataReaderFactory;
	//	2)问题报告器
	//	this.problemReporter = problemReporter;
	//	//设置环境
	//	this.environment = environment;
	//	3)资源加载器
	//	this.resourceLoader = resourceLoader;
	//	4）创建了一个组件扫描器
	//	this.componentScanParser = new ComponentScanAnnotationParser(
	//			environment, resourceLoader, componentScanBeanNameGenerator, registry);
	//	this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader);
	//	****/
    ConfigurationClassParser parser = new ConfigurationClassParser(
            this.metadataReaderFactory, this.problemReporter, this.environment,
            this.resourceLoader, this.componentScanBeanNameGenerator, registry);

    // 将要被解析的配置类(把自己的configCandidates加入到 候选的)
    Set<BeanDefinitionHolder> candidates = new LinkedHashSet<BeanDefinitionHolder>(configCandidates);
    // 已经被解析的配置类(由于do while 那么mainclass就一定会被解析,被解析的size为1)
    Set<ConfigurationClass> alreadyParsed = new HashSet<ConfigurationClass>(configCandidates.size());
    do {
        // 通过配置解析器真正的解析配置类
        parser.parse(candidates);
        // 进行校验
        parser.validate();

        // 获取ConfigClass (把解析过的配置bean定义信息获取出来)
        Set<ConfigurationClass> configClasses = new LinkedHashSet<ConfigurationClass>(parser.getConfigurationClasses());
        configClasses.removeAll(alreadyParsed);

        // Read the model and create bean definitions based on its content
        if (this.reader == null) {
            this.reader = new ConfigurationClassBeanDefinitionReader(
                    registry, this.sourceExtractor, this.resourceLoader, this.environment,
                    this.importBeanNameGenerator, parser.getImportRegistry());
        }
        // @CompentScan是直接注册Bean定义信息的    但是通过获取@Import,@Bean这种的注解还没有注册的bean定义
        this.reader.loadBeanDefinitions(configClasses);
        // 把系统解析过我们自己的组件放在alreadyParsed
        alreadyParsed.addAll(configClasses);

        // 清除解析过的 配置文件
        candidates.clear();
        // 已经注册的bean定义个数大于最新 开始系统+主配置类的(发生过解析)
        if (registry.getBeanDefinitionCount() > candidateNames.length) {
            // 获取系统+自己解析的+mainconfig的bean定义信息
            String[] newCandidateNames = registry.getBeanDefinitionNames();
            // 系统的+mainconfig的bean定义信息
            Set<String> oldCandidateNames = new HashSet<String>(Arrays.asList(candidateNames));
            // 已经解析过的自己的组件
            Set<String> alreadyParsedClasses = new HashSet<String>();
            for (ConfigurationClass configurationClass : alreadyParsed) {
                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());
            }
            for (String candidateName : newCandidateNames) {
                if (!oldCandidateNames.contains(candidateName)) {
                    // 老的（系统+mainconfig） 不包含解析的
                    // 把当前bean定义获取出来
                    BeanDefinition bd = registry.getBeanDefinition(candidateName);
                    // 检查是否为解析过的
                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &&
                            !alreadyParsedClasses.contains(bd.getBeanClassName())) {
                        // 若不是解析过且通过检查的     把当前的bean定义 加入到candidates中
                        candidates.add(new BeanDefinitionHolder(bd, candidateName));
                    }
                }
            }
            // 把解析过的赋值给原来的 
            candidateNames = newCandidateNames;
        }
    }
    // 还存主没有解析过的  再次解析
    while (!candidates.isEmpty());

    // Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes
    if (sbr != null) {
        if (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {
            sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());
        }
    }

    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {
        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();
    }
}
```

③parser.parse(candidates)

```java
public void parse(Set<BeanDefinitionHolder> configCandidates) {
    this.deferredImportSelectors = new LinkedList<DeferredImportSelectorHolder>();

    for (BeanDefinitionHolder holder : configCandidates) {
        BeanDefinition bd = holder.getBeanDefinition();
        try {
            if (bd instanceof AnnotatedBeanDefinition) {
                // 注解形式的bean定义信息
                parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
            }
            else if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) {
                parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());
            }
            else {
                parse(bd.getBeanClassName(), holder.getBeanName());
            }
        }
        catch (BeanDefinitionStoreException ex) {
            throw ex;
        }
        catch (Throwable ex) {
            throw new BeanDefinitionStoreException(
                    "Failed to parse configuration class [" + bd.getBeanClassName() + "]", ex);
        }
    }

    processDeferredImportSelectors();
}
```

④processConfigurationClass(new ConfigurationClass(reader, beanName))

```java
protected void processConfigurationClass(ConfigurationClass configClass) throws IOException {
    if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {
        return;
    }

    ConfigurationClass existingClass = this.configurationClasses.get(configClass);
    if (existingClass != null) {
        if (configClass.isImported()) {
            if (existingClass.isImported()) {
                existingClass.mergeImportedBy(configClass);
            }
            // Otherwise ignore new imported config class; existing non-imported class overrides it.
            return;
        }
        else {
            // Explicit bean definition found, probably replacing an import.
            // Let's remove the old one and go with the new one.
            this.configurationClasses.remove(configClass);
            for (Iterator<ConfigurationClass> it = this.knownSuperclasses.values().iterator(); it.hasNext();) {
                if (configClass.equals(it.next())) {
                    it.remove();
                }
            }
        }
    }

    // Recursively process the configuration class and its superclass hierarchy.
    SourceClass sourceClass = asSourceClass(configClass);
    do {
        // 递归处理配置类及其超类层次结构
        sourceClass = doProcessConfigurationClass(configClass, sourceClass);
    }
    while (sourceClass != null);

    this.configurationClasses.put(configClass, configClass);
}
```

⑤sourceClass = doProcessConfigurationClass(configClass, sourceClass);

```java
/**
  * Apply processing and build a complete {@link ConfigurationClass} by reading the
  * annotations, members and methods from the source class. This method can be called
  * multiple times as relevant sources are discovered.
  * @param configClass the configuration class being build
  * @param sourceClass a source class
  * @return the superclass, or {@code null} if none found or previously processed
  */
protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)
        throws IOException {

    // Recursively process any member (nested) classes first
    processMemberClasses(configClass, sourceClass);

    // Process any @PropertySource annotations
    // 处理@PropertySource注解
    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
            sourceClass.getMetadata(), PropertySources.class,
            org.springframework.context.annotation.PropertySource.class)) {
        if (this.environment instanceof ConfigurableEnvironment) {
            processPropertySource(propertySource);
        }
        else {
            logger.warn("Ignoring @PropertySource annotation on [" + sourceClass.getMetadata().getClassName() +
                    "]. Reason: Environment must implement ConfigurableEnvironment");
        }
    }

    // Process any @ComponentScan annotations
    // 处理@ComponentScan注解
    // 解析@ComponentScans注解的属性 封装成一个一个的componentscan对象
    Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(
            sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
    if (!componentScans.isEmpty() &&
            !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
        // 循环componentScans的set
        for (AnnotationAttributes componentScan : componentScans) {
            // The config class is annotated with @ComponentScan -> perform the scan immediately
            // 立即执行扫描解析
            Set<BeanDefinitionHolder> scannedBeanDefinitions =
                    this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
            // Check the set of scanned definitions for any further config classes and parse recursively if needed
            // 检查任何其他配置类的扫描定义集，并在需要时递归解析
            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
                // 获取原始的bean定义信息
                BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
                if (bdCand == null) {
                    bdCand = holder.getBeanDefinition();
                }
                // 检查当前的bean定义信息是不是配置类  比如MainConfig的bean定义信息
                if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {
                    // 递归调用来解析MainConfig,解析出来配置类的中导入的bean定义信息
                    parse(bdCand.getBeanClassName(), holder.getBeanName());
                }
            }
        }
    }

    // Process any @Import annotations
    // 处理@Import注解   解析Import 注解的ImportSelector  ImportBeanDefinitionRegister,@Bean这种
	//存放在ConfigClass中
    processImports(configClass, sourceClass, getImports(sourceClass), true);

    // Process any @ImportResource annotations
    // 处理 @ImportResource annotations
    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {
        AnnotationAttributes importResource =
                AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);
        String[] resources = importResource.getStringArray("locations");
        Class<? extends BeanDefinitionReader> readerClass = importResource.getClass("reader");
        for (String resource : resources) {
            String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);
            configClass.addImportedResource(resolvedResource, readerClass);
        }
    }

    // Process individual @Bean methods
    // 处理  @Bean methods
    Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);
    for (MethodMetadata methodMetadata : beanMethods) {
        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
    }

    // Process default methods on interfaces
    // 处理接口
    processInterfaces(configClass, sourceClass);

    // Process superclass, if any
    // 处理超类的
    if (sourceClass.getMetadata().hasSuperClass()) {
        String superclass = sourceClass.getMetadata().getSuperClassName();
        if (!superclass.startsWith("java") && !this.knownSuperclasses.containsKey(superclass)) {
            this.knownSuperclasses.put(superclass, configClass);
            // Superclass found, return its annotation metadata and recurse
            return sourceClass.getSuperClass();
        }
    }

    // No superclass -> processing is complete
    return null;
}
```

⑥this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName())

```java
public Set<BeanDefinitionHolder> parse(AnnotationAttributes componentScan, final String declaringClass) {
    Assert.state(this.environment != null, "Environment must not be null");
    Assert.state(this.resourceLoader != null, "ResourceLoader must not be null");

    // 创建一个类路径下的bean定义扫描器
    ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(this.registry,
            componentScan.getBoolean("useDefaultFilters"), this.environment, this.resourceLoader);

    // 为扫描器设置一个bean 名称的生成器
    Class<? extends BeanNameGenerator> generatorClass = componentScan.getClass("nameGenerator");
    boolean useInheritedGenerator = (BeanNameGenerator.class == generatorClass);
    scanner.setBeanNameGenerator(useInheritedGenerator ? this.beanNameGenerator :
            BeanUtils.instantiateClass(generatorClass));

    ScopedProxyMode scopedProxyMode = componentScan.getEnum("scopedProxy");
    if (scopedProxyMode != ScopedProxyMode.DEFAULT) {
        scanner.setScopedProxyMode(scopedProxyMode);
    }
    else {
        Class<? extends ScopeMetadataResolver> resolverClass = componentScan.getClass("scopeResolver");
        scanner.setScopeMetadataResolver(BeanUtils.instantiateClass(resolverClass));
    }

    scanner.setResourcePattern(componentScan.getString("resourcePattern"));

    for (AnnotationAttributes filter : componentScan.getAnnotationArray("includeFilters")) {
        for (TypeFilter typeFilter : typeFiltersFor(filter)) {
            scanner.addIncludeFilter(typeFilter);
        }
    }
    for (AnnotationAttributes filter : componentScan.getAnnotationArray("excludeFilters")) {
        for (TypeFilter typeFilter : typeFiltersFor(filter)) {
            scanner.addExcludeFilter(typeFilter);
        }
    }

    boolean lazyInit = componentScan.getBoolean("lazyInit");
    if (lazyInit) {
        scanner.getBeanDefinitionDefaults().setLazyInit(true);
    }

    Set<String> basePackages = new LinkedHashSet<String>();
    String[] basePackagesArray = componentScan.getStringArray("basePackages");
    for (String pkg : basePackagesArray) {
        String[] tokenized = StringUtils.tokenizeToStringArray(this.environment.resolvePlaceholders(pkg),
                ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);
        basePackages.addAll(Arrays.asList(tokenized));
    }
    for (Class<?> clazz : componentScan.getClassArray("basePackageClasses")) {
        basePackages.add(ClassUtils.getPackageName(clazz));
    }
    if (basePackages.isEmpty()) {
        basePackages.add(ClassUtils.getPackageName(declaringClass));
    }

    scanner.addExcludeFilter(new AbstractTypeHierarchyTraversingFilter(false, false) {
        @Override
        protected boolean matchClassName(String className) {
            return declaringClass.equals(className);
        }
    });
    // 真正扫描器扫描指定路径
    return scanner.doScan(StringUtils.toStringArray(basePackages));
}
```

⑦ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(this.registry,componentScan.getBoolean("useDefaultFilters"), this.environment, this.resourceLoader);

```java
/**
  * Create a new {@code ClassPathBeanDefinitionScanner} for the given bean factory and
  * using the given {@link Environment} when evaluating bean definition profile metadata.
  * @param registry the {@code BeanFactory} to load bean definitions into, in the form
  * of a {@code BeanDefinitionRegistry}
  * @param useDefaultFilters whether to include the default filters for the
  * {@link org.springframework.stereotype.Component @Component},
  * {@link org.springframework.stereotype.Repository @Repository},
  * {@link org.springframework.stereotype.Service @Service}, and
  * {@link org.springframework.stereotype.Controller @Controller} stereotype annotations
  * @param environment the Spring {@link Environment} to use when evaluating bean
  * definition profile metadata
  * @param resourceLoader the {@link ResourceLoader} to use
  * @since 4.3.6
  */
public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters,
        Environment environment, ResourceLoader resourceLoader) {

    Assert.notNull(registry, "BeanDefinitionRegistry must not be null");
    this.registry = registry;

    if (useDefaultFilters) {
        // 使用默认的扫描规则
        registerDefaultFilters();
    }
    // 设置环境变量
    setEnvironment(environment);
    // 设置资源加载器
    setResourceLoader(resourceLoader);
}
```

⑧registerDefaultFilters()

```java
/**
  * Register the default filter for {@link Component @Component}.
  * <p>This will implicitly register all annotations that have the
  * {@link Component @Component} meta-annotation including the
  * {@link Repository @Repository}, {@link Service @Service}, and
  * {@link Controller @Controller} stereotype annotations.
  * <p>Also supports Java EE 6's {@link javax.annotation.ManagedBean} and
  * JSR-330's {@link javax.inject.Named} annotations, if available.
  *
  */
@SuppressWarnings("unchecked")
protected void registerDefaultFilters() {
    // 添加了Componet的解析，这就是我们为啥@Componet @Respository @Service @Controller的  @AspectJ
    this.includeFilters.add(new AnnotationTypeFilter(Component.class));
    ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();
    try {
        // 添加Jsr 250规范的注解
        this.includeFilters.add(new AnnotationTypeFilter(
                ((Class<? extends Annotation>) ClassUtils.forName("javax.annotation.ManagedBean", cl)), false));
        logger.debug("JSR-250 'javax.annotation.ManagedBean' found and supported for component scanning");
    }
    catch (ClassNotFoundException ex) {
        // JSR-250 1.1 API (as included in Java EE 6) not available - simply skip.
    }
    try {
        // JSR330的注解
        this.includeFilters.add(new AnnotationTypeFilter(
                ((Class<? extends Annotation>) ClassUtils.forName("javax.inject.Named", cl)), false));
        logger.debug("JSR-330 'javax.inject.Named' annotation found and supported for component scanning");
    }
    catch (ClassNotFoundException ex) {
        // JSR-330 API not available - simply skip.
    }
}
```

⑨scanner.doScan(StringUtils.toStringArray(basePackages))

```java
/**
  * Perform a scan within the specified base packages,
  * returning the registered bean definitions.
  * <p>This method does <i>not</i> register an annotation config processor
  * but rather leaves this up to the caller.
  * @param basePackages the packages to check for annotated classes
  * @return set of beans registered if any for tooling registration purposes (never {@code null})
  */
protected Set<BeanDefinitionHolder> doScan(String... basePackages) {
    Assert.notEmpty(basePackages, "At least one base package must be specified");
    // 创建一个Bean定义 holder的 set
    Set<BeanDefinitionHolder> beanDefinitions = new LinkedHashSet<BeanDefinitionHolder>();
    // 循环扫描路径
    for (String basePackage : basePackages) {
        // 找到候选的组件集合
        Set<BeanDefinition> candidates = findCandidateComponents(basePackage);
        // 循环候选组件集合
        for (BeanDefinition candidate : candidates) {
            ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
            candidate.setScope(scopeMetadata.getScopeName());
            // 生成bean的名称
            String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);
            // 判断是不是抽象的beand定义
            if (candidate instanceof AbstractBeanDefinition) {
                postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
            }
            if (candidate instanceof AnnotatedBeanDefinition) {
                // 注解的bean定义
                AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
            }
            // 检查当前的和存主的bean定义是否有冲突
            if (checkCandidate(beanName, candidate)) {
                // 把候选的组件封装成BeanDefinitionHolder
                BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
                definitionHolder =
                        AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
                // 加入到bean定义的集合中
                beanDefinitions.add(definitionHolder);
                // 注册当前的bean定义信息
                registerBeanDefinition(definitionHolder, this.registry);
            }
        }
    }
    return beanDefinitions;
}
```

⑩Set<BeanDefinition> candidates = findCandidateComponents(basePackage)

```java
/**
  * Scan the class path for candidate components.
  * @param basePackage the package to check for annotated classes
  * @return a corresponding Set of autodetected bean definitions
  */
public Set<BeanDefinition> findCandidateComponents(String basePackage) {
    // 候选的bean定义信息
    Set<BeanDefinition> candidates = new LinkedHashSet<BeanDefinition>();
    try {
        // 拼接需要扫描包下面的类的路径   classpath*:com/tuling/testapplicationlistener/**/*.class
        String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +
                resolveBasePackage(basePackage) + '/' + this.resourcePattern;
        // 把路径解析成一个个.class文件
        Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath);
        boolean traceEnabled = logger.isTraceEnabled();
        boolean debugEnabled = logger.isDebugEnabled();
        // 循环.class文件的resource对象
        for (Resource resource : resources) {
            if (traceEnabled) {
                logger.trace("Scanning " + resource);
            }
            // 判断class文件是否可读
            if (resource.isReadable()) {
                try {
                    // 把resource对象 变为一个类的原信息读取器
                    MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource);
                    // 判断类的源信息读取器是否为候选的组件
                    if (isCandidateComponent(metadataReader)) {
                        // 是候选的组件
                        // 把类元信息读取器封装成一个ScannedGenericBeanDefinition
                        ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);
                        sbd.setResource(resource);
                        sbd.setSource(resource);
                        if (isCandidateComponent(sbd)) {
                            // 是候选的组件
                            if (debugEnabled) {
                                logger.debug("Identified candidate component class: " + resource);
                            }
                            // 把当前解析出来的定义的加入到 BeanDefinition的集合中
                            candidates.add(sbd);
                        }
                        else {
                            if (debugEnabled) {
                                logger.debug("Ignored because not a concrete top-level class: " + resource);
                            }
                        }
                    }
                    else {
                        if (traceEnabled) {
                            logger.trace("Ignored because not matching any filter: " + resource);
                        }
                    }
                }
                catch (Throwable ex) {
                    throw new BeanDefinitionStoreException(
                            "Failed to read candidate component class: " + resource, ex);
                }
            }
            else {
                if (traceEnabled) {
                    logger.trace("Ignored because not readable: " + resource);
                }
            }
        }
    }
    catch (IOException ex) {
        throw new BeanDefinitionStoreException("I/O failure during classpath scanning", ex);
    }
    return candidates;
}
```

⑪if (isCandidateComponent(metadataReader))

```java
/**
  * Determine whether the given class does not match any exclude filter
  * and does match at least one include filter.
  * @param metadataReader the ASM ClassReader for the class
  * @return whether the class qualifies as a candidate component
  */
protected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException {
    // 是不是被排除的
    for (TypeFilter tf : this.excludeFilters) {
        if (tf.match(metadataReader, this.metadataReaderFactory)) {
            return false;
        }
    }
    // 在被包含的组件
    for (TypeFilter tf : this.includeFilters) {
        if (tf.match(metadataReader, this.metadataReaderFactory)) {
            return isConditionMatch(metadataReader);
        }
    }
    return false;
}
```

⑫return isConditionMatch(metadataReader)

```java
/**
  * Determine whether the given class is a candidate component based on any
  * {@code @Conditional} annotations.
  * @param metadataReader the ASM ClassReader for the class
  * @return whether the class qualifies as a candidate component
  */
private boolean isConditionMatch(MetadataReader metadataReader) {
    if (this.conditionEvaluator == null) {
        this.conditionEvaluator = new ConditionEvaluator(getRegistry(), getEnvironment(), getResourceLoader());
    }
    return !this.conditionEvaluator.shouldSkip(metadataReader.getAnnotationMetadata());
}
```

* * *

# 结束

编辑地点：北京 和义东里
完成时间：2021-07-18 16:18

* * *
